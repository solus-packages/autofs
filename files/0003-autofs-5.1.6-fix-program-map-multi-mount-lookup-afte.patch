From d201c27b63bf975d7df241e599f7ed4cf0a667f7 Mon Sep 17 00:00:00 2001
From: Ian Kent <raven@themaw.net>
Date: Fri, 13 Dec 2019 09:48:50 +0800
Subject: [PATCH 03/13] autofs-5.1.6 - fix program map multi-mount lookup after
 mount fail

For the case of a singleton multi-mount program map lookup following
a mount fail (and the negative timeout has passed) the lookup key is
what's expected for an indirect map key but the the root offset map
entry already exists. This causes autofs to think it has an incorrect
lookup key and it fails the lookup when it should take the opptunity
to delete and update the cache entry since it's not actually in use
yet.

If a check is done to see if the lookup is for the root offset,
deleting the entry fails because it contains an offset. Later when
parsing is done the offset will get updated and can get out of sync
with the entry of the multi-mount owner. That's not a problem as the
offsets would be deleted on eventual expire but it's best to clean
out the entry and start a fresh so the most up to date map entry
is being used.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG                | 1 +
 modules/lookup_program.c | 7 +++++--
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index 981a033..3c784d3 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,6 +1,7 @@
 xx/xx/2020 autofs-5.1.7
 - make bind mounts propagation slave by default.
 - update ldap READMEs and schema definitions.
+- fix program map multi-mount lookup after mount fail.
 
 07/10/2019 autofs-5.1.6
 - support strictexpire mount option.
diff --git a/modules/lookup_program.c b/modules/lookup_program.c
index fcb1af7..ca20948 100644
--- a/modules/lookup_program.c
+++ b/modules/lookup_program.c
@@ -646,7 +646,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				 name_len, ent, ctxt->parse->context);
 			goto out_free;
 		} else {
-			if (me->multi) {
+			if (me->multi && me->multi != me) {
 				cache_unlock(mc);
 				warn(ap->logopt, MODPREFIX
 				     "unexpected lookup for active multi-mount"
@@ -656,8 +656,11 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			cache_unlock(mc);
 			cache_writelock(mc);
 			me = cache_lookup_distinct(mc, name);
-			if (me)
+			if (me) {
+				if (me->multi)
+					cache_delete_offset_list(mc, name);
 				cache_delete(mc, name);
+			}
 			cache_unlock(mc);
 		}
 	}
-- 
2.27.0

